## 2023-12-15 学习日志

### 输入

#### 书籍

##### 《MySQL是怎样运行的》第7章 B+树的索引使用

- 前期回顾
  - 每个索引都对应一裸 B+ 树.所有用户记录都存储在 B+ 树的叶子节点 ， 所有目录项记录都存储在内节点，聚簇索引的叶子节点包含完整的用户记录.
- 二级索引的叶子节点包含的用户记录由索引列和主键组成·如果想通过二级索引查找完整的用户记录，需要执行回表操作，到聚簇索引中查找完整的用户记录
  - 每层节点都按照索引列的值从小到大的顺序排序组成了双向链表，每个页内的记录(无论是用户记录还是目录项记录)都按照索引列的值从小到大的顺序形成了一个单向链表
  - 通过索引查找记录时，由于每个页面中的记录都划分成了若干个组， 每个组中索引列值最大的记录在页内的偏移量会被当作槽依次存放在页目录中，因此可以在页目录中通过二分法快速定位到索引列等于某个值的记录
- 索引的代价
  - 空间上的代价，而外的数据存储结构会占用空间，每建立一个索引，都要为它建立一裸 B+ 树
  - 时间上的代价
    - 需要维护与用户记录上的数据一致，所以在修改删除插入操作上，需要进行维护索引（保持数据按顺序排列）
    - 数据页满了，则会页分裂，Copy and Write，会造成 I/O 读写，当数据少了，要回收数据页
    - 索引太多，导致优化器在SQL语句成本分析变慢
  - 应用 B+ 树索引
    - 扫描区间和边界条件（SQL的扫描数据的**范围**和数据的查询**条件**），若没有索引，则是全表扫描，也是就是扫描区间，(-∞,+∞)
      - 搜索条件都可以生成合适的扫描区间的情况
        - 例如：key2> 100 和 key2 > 200，最终的扫描区间就是对这两个小的搜索条件形成的扫描区间取交集后的结果，key2>200
        - 例如：key2 > 100 OR key2 > 200，扫描区间的并集，key2 > 100
        - 有的搜索条件不能生成合适的扫描区间的情况，复杂的模索条件中找出扫描区间，化简为TRUE
        - 使用联合索引执行查询时对应的扫描区间，先搜索key-part1,然后在搜索key_part2,形成扫描区间 [('a' ,'b'), ('a','b')]
        - 如呆开启了索引条件下推的特性，该二级索引记录是否符合 key.part1 = 'c'，如果不符合则不执行回表操作
      - 索引用于排序
        - 二级索引的记录本身就是按规则排好序的
        - ORDERBY 子句后面的列的顺序也必须按照索引列的顺序给出（因为索引是按照列的排列顺序进行存储的）
        - 不可以使用索引迸行排序的几种情况
          - ASC 、 DESC 混用，只能用同一种
          - 排序列包含非同一个索引的列
          - 排序列是某个联合索引的索引列，在索引中不连续不连续
          - 用来形成扫描区间的索引列，与排序列不同，因为需要先过滤数据用到索引，后在排序
          - 排序列不是以单独列名的形式出现在 ORDERBY 子句中（函数调用）
      - 索引用于分组
        - 分组顺序，索引列的顺序是一致的， 二级索引记录又是按照索引列的值排好序的，可以直接使用索引进行分组，而不用再建立临时表了（左边连续）
      - 回表的代价
        - 索引中的数据页都必须存放在磁盘中 ， 等到需要时再加载到内存中使用，页面不在内存中，就需要将该页面从磁盘加载到内存中，数据页的页号也毫无规律，因此会造成大量的随机1/0 
        - 需要执行回表操作的记录越多 ， 使用二级索引进行查询的性能也就越低，某些查询宁愿使
          用全表扫描也不使用二级索引
        - 一般情况下， LIMIT 子句来限制查询返回的记录数 ， 这可能会让优化器倾向于选择使用二级索引+回表的方式进行查询 ， 原因是回表的记录越少 ， 性能提升就越高
      - 更好地创建和使用索引
        - 只为用于搜索、排序或分组的列创建索引
        - 考虑索引列中不重复值的个数（hash散列分布越广）
        - 索引列的类型尽量小，一次页面 IO 可以将更多的记录加载到内存中) 读写效率也就越高
        - 为列前缀建立索引，只保留字符串的前 10 个字符，可以明显减少索引大小，但无法支持使用索引进行排序的需求
        - 覆盖索引，为了彻底告别回表操作带来的性能损耗，建议最好在查询列表中只包含索引列，把查询列放入索引中
        - 让索引列以列名的形式在搜索条件中单独出现（列名不要用函数，计算等方式）
        - 新插入记录时主键大小对效率的影响，插入连续的数据，不会频繁页分裂
        - 冗余和重复索引，联合索引包含单列的索引的话，可以把单列的索引删除
- 总结
  - 索引其实是空间换时间的产物，重复innodb的引擎特性，数据页面（数据连续），页分类，页回收，加载内存等
  - 创建索引应该考虑，这几个方面：索引类型大小，索引的顺序，即查询列，Where，Order，Group By，索引是否冗余了（联合索引包含单列，单列就可以去除），（覆盖索引对于查询列不用回表），若查查询列要在索引里建立，则要考虑选择数（hash分散的范围，越分散越好区分数据，做数据切块）
  - 使用索引方面，条件列名不能做加工处理（函数，计算），要按顺序

##### 多领国 2-3-7

<img src="../../2023/img/image-20231217152949650.png" alt="image-20231217152949650" style="zoom:50%;" />

##### 墨墨背单词 大学四级（6000词）

<img src="../../2023/img/image-20231217152736539.png" alt="image-20231217152736539" style="zoom:50%;" />



##### Essential Grammar In Use (Fourth Edition)  Unit 3

![image-20231217153249317](../../2023/img/image-20231217153249317.png)

![image-20231217153303925](../../2023/img/image-20231217153303925.png)

- 现在进行时
- am/is/are + doing
- spelling  
  - -e end，去e+ing coming
  - -n,-t,-m end，双写+ing running,sitting,swimming
  - -ie end,去 ie 变为 y，lying

### 输出

暂无

